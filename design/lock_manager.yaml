# packages/lock_manager.yaml

input_text:
  lock_manager_slot_1:  { name: "Lock Manager Slot 1",  mode: text, max: 255 }
  lock_manager_slot_2:  { name: "Lock Manager Slot 2",  mode: text, max: 255 }
  lock_manager_slot_3:  { name: "Lock Manager Slot 3",  mode: text, max: 255 }
  lock_manager_slot_4:  { name: "Lock Manager Slot 4",  mode: text, max: 255 }
  lock_manager_slot_5:  { name: "Lock Manager Slot 5",  mode: text, max: 255 }
  lock_manager_slot_6:  { name: "Lock Manager Slot 6",  mode: text, max: 255 }
  lock_manager_slot_7:  { name: "Lock Manager Slot 7",  mode: text, max: 255 }
  lock_manager_slot_8:  { name: "Lock Manager Slot 8",  mode: text, max: 255 }
  lock_manager_slot_9:  { name: "Lock Manager Slot 9",  mode: text, max: 255 }
  lock_manager_slot_10: { name: "Lock Manager Slot 10", mode: text, max: 255 }
  lock_manager_slot_11: { name: "Lock Manager Slot 11", mode: text, max: 255 }
  lock_manager_slot_12: { name: "Lock Manager Slot 12", mode: text, max: 255 }
  lock_manager_slot_13: { name: "Lock Manager Slot 13", mode: text, max: 255 }
  lock_manager_slot_14: { name: "Lock Manager Slot 14", mode: text, max: 255 }
  lock_manager_slot_15: { name: "Lock Manager Slot 15", mode: text, max: 255 }
  lock_manager_slot_16: { name: "Lock Manager Slot 16", mode: text, max: 255 }
  lock_manager_slot_17: { name: "Lock Manager Slot 17", mode: text, max: 255 }
  lock_manager_slot_18: { name: "Lock Manager Slot 18", mode: text, max: 255 }
  lock_manager_slot_19: { name: "Lock Manager Slot 19", mode: text, max: 255 }
  lock_manager_slot_20: { name: "Lock Manager Slot 20", mode: text, max: 255 }


mqtt:
  sensor:
    - { name: lock_manager_slot_1,  state_topic: lock_manager/slot_1/state,  json_attributes_topic: lock_manager/slot_1/attrs  }
    - { name: lock_manager_slot_2,  state_topic: lock_manager/slot_2/state,  json_attributes_topic: lock_manager/slot_2/attrs  }
    - { name: lock_manager_slot_3,  state_topic: lock_manager/slot_3/state,  json_attributes_topic: lock_manager/slot_3/attrs  }
    - { name: lock_manager_slot_4,  state_topic: lock_manager/slot_4/state,  json_attributes_topic: lock_manager/slot_4/attrs  }
    - { name: lock_manager_slot_5,  state_topic: lock_manager/slot_5/state,  json_attributes_topic: lock_manager/slot_5/attrs  }
    - { name: lock_manager_slot_6,  state_topic: lock_manager/slot_6/state,  json_attributes_topic: lock_manager/slot_6/attrs  }
    - { name: lock_manager_slot_7,  state_topic: lock_manager/slot_7/state,  json_attributes_topic: lock_manager/slot_7/attrs  }
    - { name: lock_manager_slot_8,  state_topic: lock_manager/slot_8/state,  json_attributes_topic: lock_manager/slot_8/attrs  }
    - { name: lock_manager_slot_9,  state_topic: lock_manager/slot_9/state,  json_attributes_topic: lock_manager/slot_9/attrs  }
    - { name: lock_manager_slot_10, state_topic: lock_manager/slot_10/state, json_attributes_topic: lock_manager/slot_10/attrs }
    - { name: lock_manager_slot_11, state_topic: lock_manager/slot_11/state, json_attributes_topic: lock_manager/slot_11/attrs }
    - { name: lock_manager_slot_12, state_topic: lock_manager/slot_12/state, json_attributes_topic: lock_manager/slot_12/attrs }
    - { name: lock_manager_slot_13, state_topic: lock_manager/slot_13/state, json_attributes_topic: lock_manager/slot_13/attrs }
    - { name: lock_manager_slot_14, state_topic: lock_manager/slot_14/state, json_attributes_topic: lock_manager/slot_14/attrs }
    - { name: lock_manager_slot_15, state_topic: lock_manager/slot_15/state, json_attributes_topic: lock_manager/slot_15/attrs }
    - { name: lock_manager_slot_16, state_topic: lock_manager/slot_16/state, json_attributes_topic: lock_manager/slot_16/attrs }
    - { name: lock_manager_slot_17, state_topic: lock_manager/slot_17/state, json_attributes_topic: lock_manager/slot_17/attrs }
    - { name: lock_manager_slot_18, state_topic: lock_manager/slot_18/state, json_attributes_topic: lock_manager/slot_18/attrs }
    - { name: lock_manager_slot_19, state_topic: lock_manager/slot_19/state, json_attributes_topic: lock_manager/slot_19/attrs }
    - { name: lock_manager_slot_20, state_topic: lock_manager/slot_20/state, json_attributes_topic: lock_manager/slot_20/attrs }


automation:
  - id: lock_manager_seed_slots_on_first_run
    alias: Lock Manager – Seed slots on first run
    mode: single
    trigger:
      - platform: homeassistant
        event: start
    action:
      - variables:
          # Build default slot objects: [{slot:1, name:'', pin:'', enabled:false, busy:false}, ...]
          defaults: >
            {% set ns = namespace(out=[]) %}
            {% for i in range(1, 21) %}
            {% set ns.out = ns.out + [{'slot': i, 'name': '', 'pin': '', 'enabled': false, 'busy': false}] %}
            {% endfor %}
            {{ ns.out }}
      - repeat:
          count: 20
          sequence:
            - variables:
                idx: "{{ repeat.index }}"
                ent: "input_text.lock_manager_slot_{{ idx }}"
            - choose:
                # Only seed if the helper is blank/unknown/unavailable
                - conditions: "{{ states(ent) in ['unknown','unavailable',''] }}"
                  sequence:
                    - service: input_text.set_value
                      target:
                        entity_id: "{{ ent }}"
                      data:
                        value: "{{ defaults[idx-1] | tojson }}"



script:
  lock_manager_set_slot_name:
    alias: Lock Manager - Set Slot Name
    mode: queued
    fields:
      slot: {name: Slot number, selector: { number: } }
      name: {name: User name, selector: { text: } }
    variables:
      entity: "{{ 'input_text.lock_manager_slot_' ~ (slot | int) }}"
      obj: "{{ states(entity) | from_json }}"
      name_str: "{{ name | string }}"
      name_valid: "{{ name_str | length > 5 }}"
      new: "{{ obj | combine({'name': name|string}) }}"
    sequence:
      - if: "{{ obj.enabled and not name_valid }}"
        then:
          - service: script.lock_manager_error
            data:
              slot: "{{ slot }}"
              message: "Name too short: '{{ name }}' for lock slot {{ slot }}"
          - stop: "Name too short: '{{ name }}' for lock slot {{ slot }}"
      - service: input_text.set_value
        target:
          entity_id: "{{ entity }}"
        data:
          value: "{{ new | tojson }}"


  lock_manager_set_slot_pin:
    alias: Lock Manager - Set Slot PIN
    mode: queued
    fields:
      slot: {name: Slot number, selector: { number: } }
      name: {name: PIN, selector: { text: } }
    variables:
      entity: "{{ 'input_text.lock_manager_slot_' ~ (slot | int) }}"
      obj: "{{ states(entity) | from_json }}"
      pin_str: "{{ pin | string }}"
      pin_valid: "{{ pin_str in [none, ''] or (pin_str | string is match('^\\d{6,9}$')) }}"
      new: "{{ obj | combine({'pin': pin_str}) }}"
    sequence:
      - if: "{{ not pin_valid }}"
        then:
          - service: script.lock_manager_error
            data:
              slot: "{{ slot }}"
              message: "Invalid PIN: '{{ pin }}' for lock slot {{ slot }}"
          - stop: "Invalid PIN '{{ pin }}' for lock slot {{ slot }}"
      - service: input_text.set_value
        target:
          entity_id: "{{ entity }}"
        data:
          value: "{{ new | tojson }}"


  lock_manager_toggle_slot_enabled:
    alias: Lock Manager - Togger Slot Enabled
    mode: queued
    fields:
      slot: {name: Slot number, selector: { number: } }
    variables:
      entity: "{{ 'input_text.lock_manager_slot_' ~ (slot | int) }}"
      obj: "{{ states(entity) | from_json }}"
      current: "{{ obj.enabled | bool }}"
      new: "{{ obj | combine({'enabled': (not current)}) }}"
    sequence:
      - service: input_text.set_value
        target:
          entity_id: "{{ entity }}"
        data:
          value: "{{ new | tojson }}"


  lock_manager_set_slot_busy:
    alias: Lock Manager - Set Slot Busy
    mode: queued
    fields:
      slot: {name: Slot number, selector: { number: } }
      busy: {name: Busy, selector: { boolean: } }
    variables:
      entity: "{{ 'input_text.lock_manager_slot_' ~ (slot | int) }}"
      obj: "{{ states(entity) | from_json }}"
      new: "{{ obj | combine({'busy': busy}) }}"
    sequence:
      - service: input_text.set_value
        target:
          entity_id: "{{ entity }}"
        data:
          value: "{{ new | tojson }}"


  lock_manager_error:
    alias: Lock Manager - Report Slot Error
    mode: queued
    fields:
      message: { selector: { text: } }
      slot: { selector: { number: } }

    sequence:
    - service: persistent_notification.create
      data:
        title: "Lock Manager error"
        message: "{{ message }}"
        notification_id: "lock_manager_slot_error_{{ slot }}"
    - service: system_log.write
      data:
        level: warning
        message: "{{ message }}"
    - delay: "00:00:08"
    - service: persistent_notification.dismiss
      data:
        notification_id: "lock_manager_slot_error_{{ slot }}"
    - stop: "{{ message }}"


  lock_manager_apply_all_slots:
    alias: Lock Manager - Apply All Slots
    mode: queued
    variables:
      total: 20
    sequence:
      - service: persistent_notification.create
        data:
          notification_id: lock_manager_apply_all_slots
          title: Lock Manager
          message: "Starting apply across {{ total }} slots…"

      - repeat:
          count: "{{ total }}"
          sequence:
            - variables:
                slot: "{{ repeat.index }}"
                slot_ent: "input_text.lock_manager_slot_{{ repeat.index }}"
                slot_obj: "{{ states(slot_ent) | from_json }}"
                enabled: "{{ (slot_obj.enabled | default(false)) | bool }}"
                name: "{{ slot_obj.name | default('unnamed') }}"
            - service: persistent_notification.create
              data:
                notification_id: lock_manager_apply_all_slots
                title: Lock Manager
                message: "Applying slot {{ slot }} ({{ name }})…"
            - service: script.lock_manager_apply_slot
              data:
                slot: "{{ slot }}"
            - delay: "00:00:1"

      - service: persistent_notification.create
        data:
          notification_id: lock_manager_apply_all_slots
          title: Lock Manager
          message: "Finished applying {{ total }} slots."


  lock_manager_apply_slot:
    alias: Lock Manager - Apply Slot
    mode: parallel
    max: 20
    fields:
      slot:
        name: Slot number
        selector: { number: { min: 1, max: 20, mode: box } }
    sequence:
      - service: system_log.write
        data:
          level: warning
          message: "Applying lock slot {{ slot }}"
      - variables:
          obj: "{{ states('input_text.lock_manager_slot_' ~ slot) | from_json }}"
          lm_base: "lock_manager/slot_{{ slot }}"
          locks: >-
            {{ expand('lock.all_locks')
               | map(attribute='attributes.friendly_name')
               | list }}

      - service: mqtt.publish
        data:
          topic: "{{ lm_base }}/state"
          payload: "updating locks"

      - service: script.lock_manager_set_slot_busy
        data:
          slot: "{{ slot | int }}"
          busy: true

      - repeat:
          for_each: "{{ locks }}"
          sequence:
            - variables:
                lock: "{{ repeat.item }}"
                z2m_base: "zigbee2mqtt/{{ lock }}"
                sensor_slot: "{{ 'sensor.lock_manager_slot_' ~ slot }}"
                cur: "{{ state_attr(sensor_slot, 'locks') | default({}, true) }}"

            - service: mqtt.publish
              data:
                topic: "{{ lm_base }}/attrs"
                retain: true
                payload: >-
                  {{
                    { "locks": cur | combine({ (lock): 'applying' }) } | tojson
                  }}

            - service: mqtt.publish
              data:
                topic: "{{ z2m_base }}/set"
                payload: >
                  {{
                    {
                      "pin_code": {
                        "user": obj.slot,
                        "user_type": "unrestricted",
                        "user_enabled": obj.enabled,
                        "pin_code": obj.pin if obj.enabled else None
                      }
                    } | tojson
                  }}

            - wait_for_trigger:
                - platform: mqtt
                  topic: "{{ z2m_base }}/action"
              timeout: "00:00:15"
              continue_on_timeout: true

            - variables:
                slot_status: >-
                  {% if wait.trigger.payload == 'pin_code_deleted' %}
                    available
                  {% elif wait.trigger.payload == 'pin_code_added' %}
                    enabled
                  {% else %}
                    unknown
                  {% endif %}

            - service: mqtt.publish
              data:
                topic: "{{ lm_base }}/attrs"
                retain: true
                payload: >-
                  {{
                    { "locks": cur | combine({ (lock): slot_status }) } | tojson
                  }}

            # This forces a retained refresh in the Z2M state, which is convenient for debugging
            - service: mqtt.publish
              data:
                topic: "{{ z2m_base }}/get"
                retain: true
                payload: >
                  {{
                    {
                      "pin_code": {
                        "user": obj.slot
                      }
                    } | tojson
                  }}

      - service: mqtt.publish
        data:
          topic: "{{ lm_base }}/state"
          payload: "lock update complete"

      - service: script.lock_manager_set_slot_busy
        data:
          slot: "{{ slot | int }}"
          busy: false
